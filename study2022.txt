
传播行为

意义

PROPERGATION_MANDATORY

表示方法必须运行在一个事务中，如果当前事务不存在，就抛出异常

PROPAGATION_NESTED

表示如果当前事务存在，则方法应该运行在一个嵌套事务中。否则，它看起来和 PROPAGATION_REQUIRED 看起来没什么俩样

PROPAGATION_NEVER

表示方法不能运行在一个事务中，否则抛出异常

PROPAGATION_NOT_SUPPORTED

表示方法不能运行在一个事务中，如果当前存在一个事务，则该方法将被挂起

PROPAGATION_REQUIRED

表示当前方法必须运行在一个事务中，如果当前存在一个事务，那么该方法运行在这个事务中，否则，将创建一个新的事务

PROPAGATION_REQUIRES_NEW

表示当前方法必须运行在自己的事务中，如果当前存在一个事务，那么这个事务将在该方法运行期间被挂起

PROPAGATION_SUPPORTS

表示当前方法不需要运行在一个是事务中，但如果有一个事务已经存在，该方法也可以运行在这个事务中

undo 

dubbo  zookeeper  docker  微服务链路追踪？

spring security ,spring boot 加载机制

1、finally块一定会执行，无论是否try…catch。
2、finally前有return，会先执行return语句，并保存下来，再执行finally块，最后return。
3、finally前有return、finally块中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的结果，并返回。


redis

未学习的+面试需要的



结论:在重写了equals方法后，强制要求重写hashCode方法

如果两个对象相等，那么他们必须有相同的hashCode
如果两个对象有相同的hashCode,并不意味着他们相等
单独重写equals方法会让业务中使用哈希数据结构的数据失效，如HashMap,HashSet,HashTable…

==对比的是堆中的值///666

抽象类和接口区别

抽象类可以存在普通成员函数，⽽接⼝中只能存在public abstract ⽅法。 //抽象类可以实现函数
抽象类中的成员变量可以是各种类型的，⽽接⼝中的成员变量只能是public static final类型的。  //抽象类可以设置任意变量  接口只能默认final static 
抽象类只能继承⼀个，接⼝可以实现多个  //接口实现多继承


GC流程


debugger 中加条件，和赋值（添加evaluate expression）



Springboot 自动装配原理

Spring Boot 的@springBootApplication 包含@EnableAutoConfiguration
这个注解通过引入AutoConfigurationImportSelector 的装配类，来进行自动装配
 --通过@EnableAutoConfiguration开启自动装配，
--通过 SpringFactoriesLoader 装配过程中会加载META-INF/spring.factories中的自动配置类实现自动装配，自动配置类其实就是通过@Conditional按需加载的配置类，想要其生效必须引入spring-boot-starter-xxx包实现起步依赖


行锁，列锁？
泛型


spring 事务失效场景
1 抛出检查性异常，比如通过throw xxxException 时，事务不会回滚；解决方式:@transaction(rollbackfor = Exception.class)
2 未抛出异常时，比如通过catch住了 xxxException 时，事务不会回滚；解决方式:抛出异常 throw new RuntimeException
3 AOP切面捕捕获盗了异常  解决方式同上，也可设置AOP执行顺序
4 默认情况下@transactionl 必须指定在公有方法上，@public   ; 
5 父子容器时，@transactionl 未跟方法在同一个容器（一般不会存在两个容器）
6 传播行为时，当前对象并非实际对象而是代理对象，
7 多线程下@transactionl 加锁时，不能保证commit也加锁了，需要在commit后加锁
8 数据库事务原子性包括增删改但是不包括查select ，需要加上select for update时事务才会生效
AopContext.currentPoxy()  得到当前代理对象

反射  事务的传播机制require and requires_new
coundownlatch .await 

ctrl f12 

spring set注入时，通过三级缓存避免循环依赖，一二级缓存能在创建实例时，缓存新实例，三级缓存判断是否含有循环依赖来判断是否返回代理对象
（三级缓存解决了循环的<代理>对象
构造方式注入时，三级缓存无效，解决的两种方式，@Lazy 或者@ObjectFactory<myObject> myObject 等方法来延缓对象创建





当前急迫
粗略了解dubbo zookeeper  链路追踪？
oracle   netty  mq 
nacos?
接下来学习

elasticsearch 
log mongodb
并发编程
分布式事务
nginx
异步处理、服务解耦、流量控制（削峰）。
实现反射





一边面试一边总结

1、为什么要创建线程池？

2、创建线程池有哪些方式？

3、Executors能创建几种常用线程池？

4、线程池有哪些参数？

5，能说说线程池原理吗？

6、线程池有哪些拒绝策略？
1	ThreadPoolExecutor.AbortPolicy	默认拒绝策略，拒绝任务并抛出任务
2	ThreadPoolExecutor.CallerRunsPolicy	使用调用线程直接运行任务
3	ThreadPoolExecutor.DiscardPolicy	直接拒绝任务，不抛出错误
4	ThreadPoolExecutor.DiscardOldestPolicy	触发拒绝策略，只要还有任务新增，一直会丢弃阻塞队列的最老的任务，并将新的任务加入


7、线程池中使用到了阻塞队列，那你知道有哪些阻塞队列？

8、线程池中的核心线程如何设置呢？

9、知道线程池有哪些状态吗？

10、线程池
中的线程是如何复用的？

11、Java线程池中submit() 和 execute()方法有什么区别？

12、在工作中，有使用过线程池吗？


mq消息丢失了怎么办
生产者弄丢了数据
	开启事务
	开启 confirm 模式
RabbitMQ 弄丢了数据
开启持久化
消费端弄丢了数据
关闭自动ack,自行处理

线程池7大参数 拒绝策略有哪些 有界无界队列

final 原理
禁止指令重排序

cms 和g1 区别--------------------------------------------waiting

 优先队列
具有自定义执行顺序的顺序队列，可实现其comparable接口
 归并排序  单例模式 实现
进程之间的通信方式有哪些
索引最左原则


只重写equals 不重写hashcode 时，依然能判断对象是否相等，只是会影响hash(map)的结构。

垃圾回收器  g1  cms parallel

CMS（Concurrent Mark Sweep）
支持并发收集
以最小的停顿时间为目标的收集器。
适合老年代

G1收集器
最主要的采用分区的概念，分成多个region,分别处理
适合各个阶段的gc
G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）

redis io 多路复用

有空再看下这个asyncExecutors
看看 jmap  jstat 等等

jvm 调优

设定堆内存大小
-Xmx：堆内存最大限制。
设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代
-XX:NewSize：新生代大小
-XX:NewRatio  新生代和老生代占比
-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比

为了结构层次清晰

父容器和子容器是相互隔离的，他们内部可以存在名称相同的bean

子容器可以访问父容器中的bean，而父容器不能访问子容器中的bean

调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止

子容器中可以通过任何注入方式注入父容器中的bean，而父容器中是无法注入子容器中的bean，


202203014 花旗外包

springmvc 父子容器  


spring父容器，mvc子容器


jdk 实现 和 cglib
java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。

而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。


invoke方法为什么不能method.invoke(proxy,args[])

arraylist 的初始长度0  
0 10 1.5
集合的初始容量为0，在第一次添加元素的时候，会对集合进行扩容，扩容之后，集合容量为10；之后，当向集合中添加元素达到集合的上限(也就是minCapacity大于elementData.length)时，会对集合再次扩容，扩容为原来的3/2。

无锁的线程安全队列 设计思想
ConcurrentLinkedQueue 	无锁且线程安全，那么考虑cas,队列性质，考虑链表。

aqs
常量池  基本数据类型，字符串，final常量，引用

redis 
内存不够时
雪崩穿透时策略
缓存淘汰策略
1先进先出 2 按时间顺序 3 按访问次数最小


i++ 
synchronized 原理
responsebody 过程



synchronized 原理
对对象锁时，每个对象有一个监视器monitor,进入锁+1 ，再次进入再+1，锁释放后-1
对方法锁时，因为方法存在于栈区，只拥有一个，此时由方法里面的ACC_SYNCHRONIZED标记来判断

redission 锁原理：setnx lua机制保证原子性；问锁超时：对锁延时，
linux swap分区， cpu负载时怎么排查 ，redis 锁超时问题，spring bean自定义初始化方法。
cpu负载时怎么排查
top 命令查看cpu使用情况并定位到进程id ,再使用jstack 打印线程dump信息，定位到堆栈信息。

测试一下是否循环依赖












hello everyone ,its my honor to be here today
here is my brief introduction of myself, i graduated from  Huaiyin Institute of Technology college in jiangsu  , and very loved to learn  algorithm coding  in college. in twenty-sixteen i started my  internship on java. Later, I  started to learn how to use Spring cloud  Microservice Technology . At present, I know a lot about Technical framework such as eureka,gateway,open feigh,Hystrix and so on

I also discuss and learn some interesting algorithms or technologies with my friends as usual.  visit some interesting  websites which beyond the great firewall of china for example: v2ex, github, stackoverflow,
I position myself as an Competent [ˈkɑːmpɪtənt]  java engineer and can be responsible for any  completed java projects. 
thanks 
