spring bean的生命周期
redisson实现 分布式锁

有空再实现一下Apollo  xxljob

怎么去实现多数据源

websoket
http的返回值

设计模式的状态模式
spring 事件发布

xxljob 可以很好地使用分片功能，通过ShardingUtil.getShardingVo
vo.getindex  gettotal获取分片信息

线程池状态
java模板 工厂设计模式 
模板策略

整理下自我介绍 和项目

数据库

interrupt
事务失效场景 索引失效场景

tidb

单例模式
懒汉
系统一开始就创建
饿汉
调用时才创建
双检锁
使用valitale关键字 保证创建时线程安全
静态内部类
//使用静态内部类实现单例模式--线程安全
class SingletonStaticInner {
	private SingletonStaticInner() {
		
	}
	private static class SingletonInner {
		private static SingletonStaticInner singletonStaticInner = new SingletonStaticInner();
	}
	public static SingletonStaticInner getInstance() {
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return SingletonInner.singletonStaticInner;
	}
}
调用内部类时才会创建内部类的实例

统一处理异常
自定义继承自runtimeException的异常类



你好我叫王学平，四川南充人，17年毕业于江苏淮阴工学院，大学专业是计算机科学与技术，
16年开始在上海实习java开发，毕业后一直从事java开发工作，最近一份工作是负责汇添富基金的固收投管项目的维护与开发
这边业务上都是基于公司固收产品的管理和流程操作。比如之前负责的国债冲抵期货保证金业务
技术上的话，使用的常规的spring cloud体系架构，多数据源，主要使用的还是oracle

国债冲抵期货保证金业务的流程维护
涉及到很多流程管理
申请提交，审核，不同角色，制作申请表，o32流水冻券，邮件外发，通知期货公司，根据期货公司的返回确认结果，判断交存是否成功并进行归档，
如果失败则解冻冻券，释放可用金额。
如果交存成功了进入下个流程，提取，又走一遍审核，邮件外发，结果确认，释放解冻。
后面项目上线的时候是我负责ppt讲解介绍给三部门人员的



负责每日汇总固收交易日报
主要问题在数据收集上，多方数据源采集，比如财汇，交易等系统。存在问题比如财汇系统数据更新不及时。如果数据没更新完毕，任务需继续执行，
等待数据完全更新完毕，采集数据可能还需要区分债券code和跨交易市场债券。
数据处理展示，比如展示日经 标普，涉及到日期问题，比如有些日期美股没开市，展示上个交易日数据
根据交易量，持仓量筛选topN进行展示。

重构了类似 jenkins 的自动化部署平台
jenkins部署时是有一个日志实时滚动打印，为实现这个功能，采用了与jenkins同样的机制，将日志写入临时文件，前台去查询增量更新文件，效果很酷炫
如果程序启动失败，会在ssh命令上有返回结果。


一级债需求更新
因为原系统成熟且庞大，我们在不动原有表结构基础上，新增新的逻辑，比如新增债券扩展表，使用异步多线程机制，在原有业务完成后，新增新的逻辑，
并更新新的扩展表。这样再怎么改也不会影响到原有系统逻辑。
比如债券重新发行，之前是不支持的，需业务人员手动增删债券数据，为改造这个，新增债券是否重新发行标识，重新发现之后，将目前现有债券更换成旧债券，
重新走一遍发行流程，引入原有债券代码。

hashmap put方法

innodb 底层数据结构


分布式事务  三段提交 

分布式锁  业务超时后，锁失效了咋办



精通一下数据库 
Java内存分析工具MAT(Memory Analyzer Tool)

把知识点自成体系 ，增加表达能力


先看下这个pdf 总统的看一遍，然后再深入一些其他陌生点的东西比如 没遇到的，源码，mq,

复习下 设计模式的  数据库底层

数据库分库分表 

mysql 索引下推


今天不能玩了，补下sql 写下简单算法，单例爬楼梯 12 共有多少种可能 快排 看下？

整理下循环依赖

了解redis cluster 

哨兵 集群 

总结下项目问题

看看 spring  mq 设计模式 算法


sudo docker run -d --name wekan -p 3010:8080  wekanteam/wekan
netsh winsock reset


spring三级缓存 




得看看消息队列视频了

jvm监控  

父子类的执行顺序 静态变量 代码块，构造函数 
泛型  面试问题


线程池 阻塞队列

sql查询慢  


解决接口幂等性


索引类型 篨几所以你




压测 Hadoop kafka

明天一定要学一遍kafka


长端债券收益率与短端债券收益率

jvm调优也看下
JVM监控与调优工具 JVisualVM 

服务降级？？？？？？？？？

1、调整睡姿：尝试侧卧睡眠，因为仰卧时舌根后坠，会加重打鼾和呼吸暂停的情况。可以在背后垫个枕头或使用特制的睡眠枕头，来帮助维持侧卧姿势。

2、控制体重：肥胖是导致打鼾的一个重要因素，通过健康饮食和适当的体育锻炼来减轻体重，可以减少咽腔的狭窄和脂肪沉积从而缓解打鼾。

3、避免烟酒：吸烟和饮酒会使上气道软组织松弛，加重打鼾应尽量避免吸烟和饮酒。

4、避免过度劳累：过度劳累会使肌肉松弛，增加打鼾的风险，应保持充足的睡眠和避免过度劳累。

总结：减肥，锻炼，戒烟酒 ，睡觉侧卧位


jvm调优 
针对偶发性的oom，使用一个jvm配置可以导出堆信息，分析这个看看哪些对象占用内容多，如果是user之类的，结合业务对象，找找是不是哪里调用接口较多
造成了死循环，如果是string类型的，找不到对象，那可以看看线程信息，看看哪些接口调用慢，sql查接口响应时间
多线程查询时，可能创建的jdbc连接太多，未及时释放，也可能oom
调整堆内存


jvm调优相关

出现oom时，可设置heapdumpoutofmemory 防止oom时，有日志可分析
注意这个参数会增加磁盘占用，和性能

oom
1系统已经oom挂了
设置heapdumpoutofmemory 生成堆文件,使用java visualVM查看堆文件的信息，可根据软件下面的gcroots路径查看到对应代码
2系统还未挂
使用jmap -histo:live pid 查看堆信息
使用jmap -dump:fomat xxx pid 导出堆文件 会造成STW
或者使用arthas

jstat看栈信息
jmap看堆信息
jstat -gc 可看gc次数
young gc 如果过多：可增大新生代空间-Xmn
full gc过多：
可能有大对象（比如sql未做分页
内存泄漏，检查代码中使用io流未close的情况

代码规范检查工具，比如 Sonar等
监控jvm工具： jvisualVM




未了解
arthas

对象逃逸
User getUser(){
User user = new User;
return user;
}
这种情况，对象逃逸到栈里了，

对象逃逸优点，跟随栈的生命周期，不用考虑gc回收

g1优点

精细控制，可预测停顿时间stw,内存碎片控制：指针碰撞，优先处理（优先回收占用大的区域 region
大内存使用比较好
流程：
初始标记：从GC roots 开始标记
并发标记：通过三色法对标记的对象进行可达性分析 ，并发的
最终标记：重新标记在并发标记中产生的垃圾
筛选回收：对标记的对象开始回收，分区进行，并根据优先级处理不同的分区


在下面的情况时，使用 G1 可能比 CMS 好：

超过 50%的 Java 堆被活动数据占用；
对象分配频率或年代提升频率变化很大；
GC 停顿时间过长（长于 0.5 至 1 秒）

G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优：

第一步：开启 G1 垃圾收集器（-XX:+UseG1GC）
第二步：设置堆的最大内存（-Xms、-Xmx、-XX:G1HeapRegionSize ）
第三步：设置最大的停顿时间（-XX:MaxGCPauseMillis）
————————————————

从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6-8GB 之间。

聊聊sm2 sm3
https://blog.csdn.net/weixin_40141628/article/details/136057891

IPV6升级


sudo apt update
sudo apt install default-jdk