事务的特性（ACID）：

原子性（Atomicity）：原子性是指一个事务中的操作，要么全部成功，要么全部失败，如果失败，就回滚到事务开始前的状态。

一致性（Consistency）：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
那转账举栗子，A账户和B账户之间相互转账，无论如何操作，A、B账户的总金额都必须是不变的。

隔离性（Isolation）：隔离性是当多个用户 并发的 访问数据库时，如果操作同一张表，数据库则为每一个用户都开启一个事务，且事务之间互不干扰，也就是说事务之间的并发是隔离的。
再举个栗子，现有两个并发的事务T1和T2，T1要么在T2开始前执行，要么在T2结束后执行，如果T1先执行，那T2就在T1结束后在执行。关于数据的隔离性级别，将在后文讲到。

持久性（Durability）：持久性就是指如果事务一旦被提交，数据库中数据的改变就是永久性的，即使断电或者宕机的情况下，也不会丢失提交的事务操作。


1）Read Uncommitted（读未提交）
一个事务在执行过程中，既可以访问其他事务未提交的新插入的数据，又可以访问未提交的修改数据。如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读此行数据。此隔离级别可防止丢失更新。
2）Read Committed（读已提交）
一个事务在执行过程中，既可以访问其他事务成功提交的新插入的数据，又可以访问成功修改的数据。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。此隔离级别可有效防止脏读。
3）Repeatable Read（可重复读取）
一个事务在执行过程中，可以访问其他事务成功提交的新插入的数据，但不可以访问成功修改的数据。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。此隔离级别可有效防止不可重复读和脏读。
4）Serializable（可串行化）
提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。此隔离级别可有效防止脏读、不可重复读和幻读。但这个级别可能导致大量的超时现象和锁竞争，在实际应用中很少使用。

spring bean的生命周期

获取 BeanName，对传入的 name 进行解析，转化为可以从 Map 中获取到 BeanDefinition 的 bean name。
合并 Bean 定义，对父类的定义进行合并和覆盖，如果父类还有父类，会进行递归合并，以获取完整的 Bean 定义信息。
实例化，使用构造或者工厂方法创建 Bean 实例。
属性填充，寻找并且注入依赖，依赖的 Bean 还会递归调用 getBean 方法获取。
初始化，调用自定义的初始化方法。
获取最终的 Bean，如果是 FactoryBean 需要调用 getObject 方法，如果需要类型转换调用 TypeConverter 进行转化。

系统维护

1 (日志)文件下载，需考虑追朔符../
2 防止sql 注入，提前过滤一下
3 防止打印sql信息，规范代码写法，try catch 
4 校验码及时清理
5 退出登录清理会话信息

spring 是如何解决循环依赖的
理解1
首先不建议循环依赖
再说
1一是循环递归获取bean定义及所依赖的bean。这样当所有bean都被获取到了，那就退出递归。解决了
2二是spring 加载bean 分两步，先实例化bean，再注入放属性
解说：
也就是说，Spring在实例化一个bean的时候，是首先递归的实例化其所依赖的所有bean，直到某个bean没有依赖其他bean，此时就会将该实例返回，然后反递归的将获取到的bean设置为各个上层bean的属性的。

构造器注入
用字段/setter注入的就可以循环依赖
有时成功有时失败是由于操作系统不同导致读取jar时文件顺序不一样，最后实例创建循序不一样

Spring mvc 工作原理[Top]
流程说明（重要）：

一个http请求发送过来先经过Servlet的filter进行过滤，之后进入MVC流程

客户端（浏览器）发送请求，直接请求到 DispatcherServlet。
DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。
解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。
HandlerAdapter 会根据 Handler 来调用真正的处理器来处理请求，并处理相应的业务逻辑。调用handler的时候，如果有继承HandlerInterceptor接口，就对应拦截处理。
处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。
ViewResolver 会根据逻辑 View 查找实际的 View。
DispatcherServlet 把返回的 Model 传给 View Resolver（视图渲染）。
把 View 返回给请求者（浏览器）

spring中的设计模式[Top]
工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。
代理设计模式 : Spring AOP 功能的实现。
单例设计模式 : Spring 中的 Bean 默认都是单例的。
模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。
适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。

BeanFactory 简介以及它 和FactoryBean的区别
BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。
在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。
但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似
以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean<T>接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&符号来获取。


无论红黑还是 B 树, 都是用来解决搜索问题的, 搜索越快越好嘛. 其实最初的, 就是二叉搜索树. 如果这颗树比较平衡的话, 其搜索效率就等同于二分查找了.
 但是呢? 现实是, 二叉搜索树不平衡, 如果不平衡, 你想想, 搜索效率就很差了.
 所以呢? 能不能构建二叉搜索树时能让它尽量平衡一些? 于是就有了平衡二叉搜索树.
 但是呢, 平衡二叉搜索树插入删除比较麻烦. 为了这种平衡, 付出代价太大(如果你就创建一次, 不经常变动也没事, 反正只有变动时才有代价) 为了即要平衡, 又不想付出太大代价, 就有了红黑树了
 当然, 红黑树消除了插入删除的代价, 所以, 对于 HashMap 的某一个 bucket, 如果元素很多, 使用红黑树是很适合了.(因为 HashMap 一般经常要删除和修改)
 到了这里, 红黑树还是二叉树, 层还是比较深的, 和搜索的过程是和层的深度是有关的, 每一次要到某一层的节点加载到内存来比较. 如果所有数据都在内存没问题, 但数据要是在磁盘呢? 
 每加载一次就是从磁盘到内存的一次 IO, 你也知道, 磁盘读写是很慢的. 所以能不能尽量减少这种 IO 呢? 
 B 树就可以了, B 树不是二叉树, B 树是一种多叉搜索树, 每一个节点都有多个元素. 这样, 对于全部节点固定情况下, B 树肯定比红黑树要浅了, 这样, 潜在的最大 IO 次数一定少了啊. 所以 B 树就应用在数据库的场景下. 
 同理, 如果你的搜索涉及到多种速度不一的存储介质, 也是可以考虑 B 树的. 

Eureka工作流程：

Eureka Server 启动成功，等待服务端注册。在启动过程中如果配置了集群，集群之间定时通过 Replicate 同步注册表，每个 Eureka Server 都存在独立完整的服务注册表信息
Eureka Client 启动时根据配置的 Eureka Server 地址去注册中心注册服务
Eureka Client 会每 30s 向 Eureka Server 发送一次心跳请求，证明客户端服务正常
当 Eureka Server 90s 内没有收到 Eureka Client 的心跳，注册中心则认为该节点失效，会注销该实例
单位时间内 Eureka Server 统计到有大量的 Eureka Client 没有上送心跳，则认为可能为网络异常，进入自我保护机制，不再剔除没有上送心跳的客户端
当 Eureka Client 心跳请求恢复正常之后，Eureka Server 自动退出自我保护模式
Eureka Client 定时全量或者增量从注册中心获取服务注册表，并且将获取到的信息缓存到本地
服务调用时，Eureka Client 会先从本地缓存找寻调取的服务。如果获取不到，先从注册中心刷新注册表，再同步到本地缓存
Eureka Client 获取到目标服务器信息，发起服务调用
Eureka Client 程序关闭时向 Eureka Server 发送取消请求，Eureka Server 将实例从注册表中删除

分布式系统CAP
Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）
三选2  及其证明：假如某个机器挂了，那么要么读非一致性的数据，要么等待获取最新的
Eureka 保证AP性


1.JVM的类加载机制主要有如下3种。

全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。

类加载器工作机制：
1.装载：将Java二进制代码导入jvm中，生成Class文件。
2.连接：a）校验：检查载入Class文件数据的正确性 b）准备：给类的静态变量分配存储空间 c）解析：将符号引用转成直接引用
3：初始化：对类的静态变量，静态方法和静态代码块执行初始化工作。
双亲委派模型：类加载器收到类加载请求，首先将请求委派给父类加载器完成 用户自定义加载器->应用程序加载器->扩展类加载器->启动类加载器。



心态炸裂都同时，是否意识到了自己的问题及不足？ 另外，你的定位是什么？比如 你对自己对定位就是一个普通开发工程师，那么问的高级问题答不上来，可以“理所当然的认为没问题”因为这个超刚于你的定位，而不必有受挫心理。 jvm 不要求你非常懂，但是内存模型，类加载机制弄清楚是必要的。 hashmap 老是会被问，你哪怕是背下来，也不过分啊！ juc 包下常用的就那些，每个都看看，写个例子，人家问起来你多少能说点，这个要求也不过分啊！ mysql 事务得清楚，事务隔离级别得清楚，索引问题，sql 优化 多少知道一点不过分啊。 redis 的几种数据类型，redis 实现分布式锁，主从，哨兵，集群 是什么概念，在自己电脑上搭建一下。 spring 源码太多了，就看一点行不行？就看 springmvc 是怎么回事行不行？（入口 DispatcherServlet ） 算法问题没发突击的，也跟脑子有关，至少得记住二分查找，冒泡排序，链表反转。比如，其他的不会，我的定位就是普通码农，也没啥可嘲笑的。你问了我就说不会。 总之，自己是啥水平，自己定位是啥，这个定位下我应该能回到出什么样的水平，我这个水平我该要多少工资。实事求是，超纲的题我认了，不必自虐，不必自我否认。


1. 你用过HashMap吗, 什么是HashMap? 为什么用到它?

用过, 然后可以接着回答一些HashMap的特性, 比如HashMap可以接收null键值和值, 而HashTable则不能, HashMap是非synchronized的; HashMap很快, 以及HashMap存储的是键值对等.

2. 你知道HashMap的工作原理吗? 你知道HashMap的get() 方法的工作原理吗?

HashMap是基于hashing的原理, 我们使用put(key, value) 存储对象到HashMap中, 使用get(key) 从HashMap中获取对象, 当我们给put() 方法传键和值时, 我们先对键调用hashCode()方法, 返回的hashCode用于找到bucket的位置来存储entry对象.

这里关键点在于指出, HashMap是在bucket中存储键对象和值对象, 作为Map.Entry 这一点有助于理解获取对象的逻辑.  如果你没有意识到这一点, 或者错误的认为仅仅只在bucket中存储值的话, 你将不会回答如何从HashMap中获取对象的逻辑. 

3. 当两个对象的hashCode相同会发生什么?

这个问题一般是分界点了. 一般同学都会回答, 因为hashCode相同, 所以两个对象是相等的, HashMap将会抛出异常, 或者不会存储它们.  

这个时候, 如果面试官对你之前的回答比较满意, 可能会提醒你他们有equals()和hashCode(0两个方法, 并告诉他们两个对象就算hashCode相同, 但是他们可能并不相等.  如果掌握的不太好, 可能这个问题就会不了了之.

而这个题的答案是: 因为hashCode相同, 所以他们的bucket位置相同, 碰撞会发生, 因为HashMap使用链表存储对象, 这个Entry(包含有键值对的Map.Entry)会存储在链表中, 这个时候要根据hashCode来划分数组, 如果数组的坐标相同, 则进入链表这个数据结构中了, 一般的添加都在最前面, 也就是和数组下标直接相连的地方, 链表长度到达8的时候, JDK1.8上升为红黑树. 这样回答基本就ok了, 要不要接着往下问, 就看面试官了. 

4. 如果两个键的hashCode相同, 你如何获取值对象?

同学们一般会说 :  当我们调用get(0 方法, HashMap会使用键对象的hashcode找到bucket位置, 然后获取值对象, 面试官会提醒, 如果有两个值对象存储在同一个bucket, 面试者会说, 将会遍历链表直到找到值对象. 面试官会问, 你没有值对象去比较, 怎么确定找到值对象的. 这个题的重点是, 找到bucket位置后, 调用keys.value() 方法去找链表中正确的结点, 最终找到要找的值对象.

正确的完整回答应该是这样 : 

当我们调用get() 方法, HashMap会使用键对象的hashCode找到bucket位置, 然后获取值对象. 如果有两个值对象存储在同一个bucket, 将会遍历LinkedList知道找到值对象, 找到bucket位置之后, 会调用keys.equals() 方法找到LinkedList中正确的结点, 最终找到要找的值对象. ( 当程序通过key取到对应的value时, 系统只要先计算出该key的hashCode() 返回值, 在根据该hashCode返回值找出该key在table数组中的索引, 然后取出该索引除的Entry, 最后返回该key对应的value即可)

5. 如果HashMap的大小超过了负载因子(load factor)定义的容量, 该怎么办 ?

默认的负载因子是0.75, 也就是说, 当一个map填满了75%的bucket时, 和其他集合类一样, 就会创建原来HashMap大小的两倍的bucket数组, 来重新调整map的大小, 并将原来的对象放入新的bucket数组中, 这个过程叫rehashing, 因为他调用hash方法找到新的bucket位置.

6. 你了解重新调整HashMap大小存在什么问题吗?

如果这个时候答不出来, 面试官可能会提醒你当多线程的情况下, 可能会产生条件竞争

当重新调整HahMap时, 确实存在条件竞争, 因为如果两个线程都发现HashMap需要重新调整大小了, 他们会试着同时调整大小, 在调整大小的过程中, 存储在链表中的元素的次序会反过来, 因为移动到新的bucket位置的时候, HashMap并不会将元素放在链表的尾部, 而是放在头部, 这是为了避免尾部遍历. 如果条件竞争发生了, 那么就死循环了. 这个时候, 你可以质问面试官, 问什么这么奇怪, 要在多线程的环境下使用HashMap

ReentrantLock 和 synchronize 底层原理
Synchronized
对整个对象加锁，监视器锁（monitor）,线程占有时加一，释放-1。
ReentrantLock
	1.等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。

	2.公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。

	公平锁、非公平锁的创建方式：

	//创建一个非公平锁，默认是非公平锁Lock lock = new ReentrantLock();Lock lock = new ReentrantLock(false); //创建一个公平锁，构造传参trueLock lock = new ReentrantLock(true);

	3.锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。

ReenTrantLock实现的原理：
CAS+CLH队列来实现。它支持公平锁和非公平锁，两者的实现类似。
CAS：Compare and Swap
比较并交换。CAS有3个操作数：内存值V、预期值A、要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。该操作是一个原子操作，被广泛的应用在Java的底层实现中。在Java中，CAS主要是由sun.misc.Unsafe这个类通过JNI调用CPU底层指令实现。
CLH队列（这个以后再学习吧）


“你能不能谈谈，java GC是在什么时候，对什么东西，做了什么事情？”
在什么时候：
1.新生代有一个Eden区和两个survivor区，首先将对象放入Eden区，如果空间不足就向其中的一个survivor区上放，如果仍然放不下就会引发一次发生在新生代的minor GC，将存活的对象放入另一个survivor区中，然后清空Eden和之前的那个survivor区的内存。在某次GC过程中，如果发现仍然又放不下的对象，就将这些对象放入老年代内存里去。
2.大对象以及长期存活的对象直接进入老年区。
3.当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析，如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小，那么执行一次Full GC以尽可能地获得老年区的空间。
对什么东西：从GC Roots搜索不到，而且经过一次标记清理之后仍没有复活的对象。
做什么： 新生代：复制清理； 老年代：标记-清除和标记-压缩算法； 永久代：存放Java中的类和加载类的类加载器本身。
GC Roots都有哪些： 1. 虚拟机栈中的引用的对象 2. 方法区中静态属性引用的对象，常量引用的对象 3. 本地方法栈中JNI（即一般说的Native方法）引用的对象。


quartz 基本原理

Quartz核心要素有Scheduler、Trigger、Job、JobDetail，其中trigger和job、jobDetail为元数据，而Scheduler为实际进行调度的控制器。

Trigger
Trigger用于定义调度任务的时间规则，在Quartz中主要有四种类型的Trigger：SimpleTrigger、CronTrigger、DataIntervalTrigger和NthIncludedTrigger。

Job&Jodetail
Quartz将任务分为Job、JobDetail两部分，其中Job用来定义任务的执行逻辑，而JobDetail用来描述Job的定义（例如Job接口的实现类以及其他相关的静态信息）。对Quartz而言，主要有两种类型的Job，StateLessJob、StateFulJob

Scheduler
实际执行调度逻辑的控制器，Quartz提供了DirectSchedulerFactory和StdSchedulerFactory等工厂类，用于支持Scheduler相关对象的产生。


什么时候拆微服务，按功能，按资源消耗。。。。。。

sql:
row_number() over (partition by class order by score desc) as rank where rank = 1
取每门课最高成绩的data 
例  1 2 3

RANK()
定义：RANK()函数，顾名思义排名函数，可以对某一个字段进行排名，例：1 1 3  
DENSE_RANK()  例 1 1 2 

NTILE()
对数据进行按指定数量分区  例 NTILE(2)  =  1 1 2 2 3 3 没用过

sql 优化
like xx% 走索引，其他like 均不走索引
垂直分表？水平   oracle垂直分区和水平分区？？？
索引的类型

oracle 分页
select * from(
    select A.*,rownum num from(
       select * from t_order order by xxx)A
    where rownum<=15)
  where num>=5)
为什么要使用三层嵌套，因为oracle先select 再 order by ，导致第一次查出来的rownum 会错乱，所以正确的第一次查询
应该查询所有的值，包括order by 后面的

为什么ConcurrentHashMap是线程安全的
JDK1.7中，ConcurrentHashMap使用的锁分段技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

那说说JDK1.7中Segment的原理
刚刚说的一段一段就是指Segment，它继承了ReentrantLock，具备锁和释放锁的功能。ConcurrentHashMap只有16个Segment，并且不会扩容，最多可以支持16个线程并发写。

JDK1.8的ConcurrentHashMap怎么实现线程安全的
JDK1.8放弃了锁分段的做法，采用CAS和synchronized方式处理并发。以put操作为例，CAS方式确定key的数组下标，synchronized保证链表节点的同步效果。

JDK1.8的做法有什么好处呢

减少内存开销
假设使用可重入锁，那么每个节点都需要继承AQS，但并不是每个节点都需要同步支持，只有链表的头节点（红黑树的根节点）需要同步，这无疑消耗巨大内存。
获得JVM的支持
可重入锁毕竟是API级别的，后续的性能优化空间很小。synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。
HashTable也是线程安全的，为什么不推荐使用HashTable呢
HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为多个线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。

oracle 几种索引
normal unique  bitmap(用于基数少的情况，使用位图创建索引，引入b树索引，平衡搜索多叉树)

索引失效的几种情况
小于符号不走索引，大于符号走索引
0.没有 WHERE 子句 
1．隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误。 
2.使用 IS NULL 和 IS NOT NULL 
3.WHERE 子句中使用函数不规范 
3.1转变一下： 
3.2基于函数的索引： 
4.使用 LIKE ‘%T’ 进行模糊查询 
5.对索引列进行运算导致索引失效,我所指的对索引列进行运算包括(+，-，*，/，! 等) 
6.WHERE 子句中使用不等于操作 
7.等于和范围索引不会被合并使用 
8. 不要在 SQL 代码中使用双引号。 
9. 将索引所在表空间和数据所在表空间分别设于不同的磁盘chunk上，有助于提高索引查询的效率。 
10. Oracle默认使用的基于代价的SQL优化器（CBO）非常依赖于统计信息，一旦统计信息不正常，会导致数 据库查询时不使用索引或使用错误的索引。 
11. Oracle在进行一次查询时，一般对一个表只会使用一个索引。 
12. 优先且尽可能使用分区索引。


redis 
数据结构
String
Hash （存的hashmap）
List  双向链表 可用作消息队列
Set  去重list  内部实现是一个 value永远为null的HashMap
Sorted Set   有序set



todo list 

juc
sql 优化
索引问题
redis 实现分布式锁 主从，哨兵，集群
todo list 
分布式事务 我记得有分段式提交等

springboot 自动装配原理
merge into 

服务选举机制。。。

netty?
nio及相关
多线程
Elasticsearch
fastDFS 








