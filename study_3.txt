

int    4字节    （-2^31）-（2^31 - 1）；float    4字节 double    8字节

synchronized的缺陷：当某个线程进入同步方法获得对象锁，那么其他线程访问这里对象的同步方法时，必须等待或者阻塞，这对高并发的系统是致命的，这很容易导致系统的崩溃。如果某个线程在同步方法里面发生了死循环，那么它就永远不会释放这个对象锁，那么其他线程就要永远的等待。这是一个致命的问题。


详解Redis中两种持久化机制RDB(面试常问，工作常用)
RDB（快照）持久化默认
AOF（append only file）持久化

建议两种方式配合使用
redis提供了rdb持久化方案，为什么还要aof？
优化数据丢失问题，rdb会丢失最后一次快照后的数据，aof丢失不会超过2秒的数据


对象锁也叫方法锁，是针对一个对象实例的，它只在该对象的某个内存位置声明一个标识该对象是否拥有锁，所有它只会锁住当前的对象，而并不会对其他对象实例的锁产生任何影响，不同对象访问同一个被synchronized修饰的方法的时候不会阻塞,

类锁 实际就是指的synchronized 修饰静态方法
不管多少个对象,多少个对象,共用一把多,且只有一把,不管怎么调用,都会同步


inteface 声明变量可以，只能且默认为final的，不能修改，且优先使用子类的初始化。

1.Java中HashSet是用散列表实现的，散列表的大小默认为16，加载因子为0.75.

2.去重原理：当hashset add一个元素A的时候，首先获取这个元素的散列码（hashcode的方法），即获取元素的哈希值。

情况一：如果计算出的元素的存储位置目前没有任何元素存储，那么该元素可以直接存储在该位置上。

情况二：如果算出该元素的存储位置目前已经存在有其他元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，如果equals返回的值是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行添加。


todo list
zp 

































